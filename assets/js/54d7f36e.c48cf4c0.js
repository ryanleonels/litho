"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7377],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>s,MDXProvider:()=>c,mdx:()=>f,useMDXComponents:()=>d,withMDXComponents:()=>m});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},r.apply(this,arguments)}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),m=function(e){return function(t){var n=d(t.components);return o.createElement(e,r({},t,{components:n}))}},d=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},c=function(e){var t=d(e.components);return o.createElement(s.Provider,{value:t},e.children)},u="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),m=d(n),c=a,u=m["".concat(l,".").concat(c)]||m[c]||y[c]||r;return n?o.createElement(u,p(p({ref:t},s),{},{components:n})):o.createElement(u,p({ref:t},s))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=h;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p[u]="string"==typeof e?e:a,l[1]=p;for(var s=2;s<r;s++)l[s]=n[s];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},87353:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>i,default:()=>y,frontMatter:()=>p,metadata:()=>s,toc:()=>d});var o=n(87462),a=n(63366),r=(n(67294),n(3905)),l=["components"],p={id:"props",title:"Types of Props",keywords:["litho props","common props","tree props","treeprops","treeprop","litho style"]},i=void 0,s={unversionedId:"mainconcepts/props",id:"mainconcepts/props",title:"Types of Props",description:"The Components page details how to declare a component and its props as standard val properties. This page covers two more ways for a parent component to configure its children with props: Common props and Tree props.",source:"@site/../docs/mainconcepts/props.mdx",sourceDirName:"mainconcepts",slug:"/mainconcepts/props",permalink:"/docs/mainconcepts/props",draft:!1,editUrl:"https://github.com/facebook/litho/edit/master/website/../docs/mainconcepts/props.mdx",tags:[],version:"current",frontMatter:{id:"props",title:"Types of Props",keywords:["litho props","common props","tree props","treeprops","treeprop","litho style"]},sidebar:"mainSidebar",previous:{title:"Components",permalink:"/docs/mainconcepts/components-basics"},next:{title:"Introduction to Hooks",permalink:"/docs/mainconcepts/hooks-intro"}},m={},d=[{value:"Common Props",id:"common-props",level:2},{value:"Combining a Style from above with a local Style",id:"combining-a-style-from-above-with-a-local-style",level:3},{value:"Working with Style",id:"working-with-style",level:3},{value:"Java - Kotlin compatibility",id:"java---kotlin-compatibility",level:3},{value:"Tree Props",id:"tree-props",level:2},{value:"Declaring a Tree Prop",id:"declaring-a-tree-prop",level:3},{value:"Using a Tree Prop",id:"using-a-tree-prop",level:3},{value:"When to Use Tree Props",id:"when-to-use-tree-props",level:3}],c={toc:d},u="wrapper";function y(e){var t=e.components,n=(0,a.Z)(e,l);return(0,r.mdx)(u,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"The ",(0,r.mdx)("a",{parentName:"p",href:"/docs/mainconcepts/components-basics"},"Components")," page details how to declare a component and its ",(0,r.mdx)("strong",{parentName:"p"},"props")," as standard ",(0,r.mdx)("inlineCode",{parentName:"p"},"val")," properties. This page covers two more ways for a parent component to configure its children with props: ",(0,r.mdx)("a",{parentName:"p",href:"#common-props"},"Common props")," and ",(0,r.mdx)("a",{parentName:"p",href:"#tree-props"},"Tree props"),"."),(0,r.mdx)("h2",{id:"common-props"},"Common Props"),(0,r.mdx)("admonition",{type:"note"},(0,r.mdx)("p",{parentName:"admonition"},"A common prop is one of a set of properties that can be applied to any primitive component.")),(0,r.mdx)("p",null,"Common props are supported by all primitive components. They include View properties like ",(0,r.mdx)("inlineCode",{parentName:"p"},"onClick")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"background"),", visibility events like ",(0,r.mdx)("inlineCode",{parentName:"p"},"onVisible"),", as well as layout parameters like ",(0,r.mdx)("inlineCode",{parentName:"p"},"margin"),"."),(0,r.mdx)("p",null,"Common props are specified using the ",(0,r.mdx)("inlineCode",{parentName:"p"},"Style")," API, which enables one or more common props to be chained together into a Style object that is passed to the components as a prop, as shown in the following example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-kotlin"},'val style = Style.margin(all = 4.px)\n    .backgroundColor(Color.RED)\n    .viewTag("my_view")\n')),(0,r.mdx)("p",null,"For a component to be configured with a Style, it should declare a Style prop (such as ",(0,r.mdx)("inlineCode",{parentName:"p"},"val style: Style? = null"),"). It should then pass that Style object to one of the components it renders to, usually the root component it returns from ",(0,r.mdx)("inlineCode",{parentName:"p"},"render"),". In this way, the Style will eventually end up on a primitive component (for example, ",(0,r.mdx)("inlineCode",{parentName:"p"},"Text")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"Row)"),". All common props end up being materialized by primitive components, as shown in the following example:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/HelloComponent.kt start=start_styled_example end=end_styled_example",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/HelloComponent.kt",start:"start_styled_example",end:"end_styled_example"},'class StyledHelloComponent(private val name: String, private val style: Style? = null) :\n    KComponent() {\n\n  override fun ComponentScope.render(): Component {\n    return Text(style = style, text = "Hello $name!")\n  }\n}\n\nval componentWithOnClick =\n    StyledHelloComponent(name = "Common Props", style = Style.onClick { log("clicked!") })\n')),(0,r.mdx)("h3",{id:"combining-a-style-from-above-with-a-local-style"},"Combining a Style from above with a local Style"),(0,r.mdx)("p",null,"The following 'more advanced' example shows how you can combine a Style taken from above with the Style the component itself wants to define:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/ChildStylesExample.kt start=start_combine_style_example end=end_combine_style_example",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/ChildStylesExample.kt",start:"start_combine_style_example",end:"end_combine_style_example"},'class OuterTextComponent : KComponent() {\n  override fun ComponentScope.render(): Component {\n    return InnerTextComponent(style = Style.margin(all = 8.dp))\n  }\n}\n\nclass InnerTextComponent(private val style: Style? = null) : KComponent() {\n  override fun ComponentScope.render(): Component {\n    return Text(\n        style = Style.padding(all = 8.dp).alpha(.5f) + style,\n        text = "I accept style from a parent!")\n  }\n}\n')),(0,r.mdx)("h3",{id:"working-with-style"},"Working with Style"),(0,r.mdx)("p",null,"In the above example, you may have noticed the use of ",(0,r.mdx)("inlineCode",{parentName:"p"},"+")," to combine the Style passed from ",(0,r.mdx)("inlineCode",{parentName:"p"},"OuterTextComponent")," and the styles that ",(0,r.mdx)("inlineCode",{parentName:"p"},"InnerTextComponent")," defines. The ",(0,r.mdx)("inlineCode",{parentName:"p"},"+")," operator combines two Styles into a single Style without mutating either:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-kotlin"},"val alphaStyle = Style.alpha(1f)\nval combinedStyle = alphaStyle + Style.padding(all = 8.dp).margin(all = 8.dp)\n\n// Result:\n//   alphaStyle: (alpha: 1f)\n//   combinedStyle: (alpha: 1f) <- (padding-all: 8.dp) <- (margin-all: 8.dp)\n")),(0,r.mdx)("p",null,"Note that ordering around ",(0,r.mdx)("inlineCode",{parentName:"p"},"+")," matters: if a Style property is defined twice, the ",(0,r.mdx)("strong",{parentName:"p"},"last")," definition takes precendence:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-kotlin"},"val alphaStyle = Style.alpha(1f)\nval combinedStyle = alphaStyle + Style.padding(all = 8.dp).alpha(.5f)\n\n// Result:\n//   combinedStyle will apply padding of 8.dp and alpha of .5f\n")),(0,r.mdx)("p",null,"Generally, ",(0,r.mdx)("inlineCode",{parentName:"p"},"Style")," objects are immutable: any time you combine styles or add new properties to a style, you get a new ",(0,r.mdx)("inlineCode",{parentName:"p"},"Style")," instance that contains all the properties of the previous style plus the new properties."),(0,r.mdx)("h3",{id:"java---kotlin-compatibility"},"Java - Kotlin compatibility"),(0,r.mdx)("p",null,"If you need to pass down a style from a Java class to a Kotlin component, use ",(0,r.mdx)("inlineCode",{parentName:"p"},"StyleCompat"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-java",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/OuterStyleComponentSpec.java start=start_combine_style_outer_example end=end_combine_style_outer_example",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/OuterStyleComponentSpec.java",start:"start_combine_style_outer_example",end:"end_combine_style_outer_example"},"@LayoutSpec\nclass OuterStyleComponentSpec {\n\n  @OnCreateLayout\n  static Component onCreateLayout(ComponentContext c) {\n    return new InnerTextComponent(StyleCompat.marginDip(YogaEdge.ALL, 8).build());\n  }\n}\n")),(0,r.mdx)("p",null,"For passing style from Kotlin code to a Java Spec component, you can use ",(0,r.mdx)("inlineCode",{parentName:"p"},".kotlinStyle()"),", which is equivalent to setting all the common props the ",(0,r.mdx)("inlineCode",{parentName:"p"},"Style")," defines:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/ChildStylesExample.kt start=start_combine_java_kotlin_style_example end=end_combine_java_kotlin_style_example",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/documentation/ChildStylesExample.kt",start:"start_combine_java_kotlin_style_example",end:"end_combine_java_kotlin_style_example"},"class OuterStyleKComponent : KComponent() {\n  override fun ComponentScope.render(): Component {\n    val style = Style.margin(all = 8.dp)\n    return OuterStyleComponent.create(context).kotlinStyle(style).build()\n  }\n}\n")),(0,r.mdx)("h2",{id:"tree-props"},"Tree Props"),(0,r.mdx)("admonition",{type:"note"},(0,r.mdx)("p",{parentName:"admonition"},"A tree prop is a special type of prop that is transparently passed from a parent component to its children.")),(0,r.mdx)("p",null,"A TreeProp is a special type of prop which is transparently passed from a parent component to its children. It provides a convenient way to share contextual data or utilities in a tree without having to explicitly pass ",(0,r.mdx)("inlineCode",{parentName:"p"},"val")," properties to every component in your hierarchy."),(0,r.mdx)("h3",{id:"declaring-a-tree-prop"},"Declaring a Tree Prop"),(0,r.mdx)("p",null,"In order to declare a TreeProp you need to use ",(0,r.mdx)("inlineCode",{parentName:"p"},"TreePropProvider"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/treeprops/TreePropsExampleComponent.kt start=declaring_tree_prop_start end=declaring_tree_prop_end",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/treeprops/TreePropsExampleComponent.kt",start:"declaring_tree_prop_start",end:"declaring_tree_prop_end"},"return TreePropProvider(\n    Typeface::class.java to Typeface.DEFAULT_BOLD,\n    String::class.java to getTextTitle(),\n    Int::class.java to Color.RED) {\n      TreePropsChildComponent()\n    }\n")),(0,r.mdx)("admonition",{type:"note"},(0,r.mdx)("p",{parentName:"admonition"},"You can only declare one TreeProp for any one given type. If a child of ParentComponent also defines a TreeProp of the given type, it will override the value of that TreeProp for all its children (but not for itself).")),(0,r.mdx)("h3",{id:"using-a-tree-prop"},"Using a Tree Prop"),(0,r.mdx)("p",null,"The child component can access the TreeProp value through a ",(0,r.mdx)("inlineCode",{parentName:"p"},"ComponentScope.getTreeProp<>()")," method that has the same type that was declared in the parents ",(0,r.mdx)("inlineCode",{parentName:"p"},"TreePropProvider")," call:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-kotlin",metastring:"file=sample/src/main/java/com/facebook/samples/litho/kotlin/treeprops/TreePropsChildComponent.kt start=using_tree_prop_start end=using_tree_prop_end",file:"sample/src/main/java/com/facebook/samples/litho/kotlin/treeprops/TreePropsChildComponent.kt",start:"using_tree_prop_start",end:"using_tree_prop_end"},"val color = getTreeProp<Int>()\nval typeface = getTreeProp<Typeface>()\nval title = getTreeProp<String>()\n")),(0,r.mdx)("h3",{id:"when-to-use-tree-props"},"When to Use Tree Props"),(0,r.mdx)("p",null,"Tree Props are powerful, but if overused, they can make your component code more difficult to understand. The best practice is to only use tree props for properties that the whole tree needs to know about (such as theming information or loggers) and not just as a more convenient way to get props to the leaves of a tree of components."))}y.isMDXComponent=!0}}]);