/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.facebook.litho.view

import android.animation.StateListAnimator
import android.graphics.Color
import android.graphics.drawable.Drawable
import android.os.Build
import android.util.SparseArray
import android.view.ViewOutlineProvider
import androidx.annotation.ColorInt
import androidx.annotation.IdRes
import com.facebook.kotlin.compilerplugins.dataclassgenerate.annotation.DataClassGenerate
import com.facebook.litho.ClickEvent
import com.facebook.litho.CommonProps
import com.facebook.litho.Component
import com.facebook.litho.ComponentContext
import com.facebook.litho.InterceptTouchEvent
import com.facebook.litho.LongClickEvent
import com.facebook.litho.Style
import com.facebook.litho.StyleItem
import com.facebook.litho.StyleItemField
import com.facebook.litho.TouchEvent
import com.facebook.litho.drawable.ComparableColorDrawable
import com.facebook.litho.eventHandler
import com.facebook.litho.eventHandlerWithReturn
import com.facebook.rendercore.Dimen
import com.facebook.yoga.YogaEdge

/** Enums for [ObjectStyleItem]. */
@PublishedApi
internal enum class ObjectField : StyleItemField {
  BACKGROUND,
  CLICKABLE,
  CLIP_CHILDREN,
  CLIP_TO_OUTLINE,
  DUPLICATE_CHILDREN_STATES,
  DUPLICATE_PARENT_STATE,
  FOCUSABLE,
  FOREGROUND,
  ON_CLICK,
  ON_INTERCEPT_TOUCH,
  ON_LONG_CLICK,
  ON_TOUCH,
  OUTLINE_PROVIDER,
  SELECTED,
  STATE_LIST_ANIMATOR,
  TEST_KEY,
  TRANSITION_NAME,
  WRAP_IN_VIEW,
  VIEW_ID,
  VIEW_TAG,
  VIEW_TAGS,
  ENABLED,
}

/** Enums for [FloatStyleItem]. */
@PublishedApi
internal enum class FloatField : StyleItemField {
  ALPHA,
  ROTATION,
  ROTATION_X,
  ROTATION_Y,
  SCALE,
}

/** Enums for [FloatStyleItem]. */
@PublishedApi
internal enum class DimenField : StyleItemField {
  TOUCH_EXPANSION_START,
  TOUCH_EXPANSION_TOP,
  TOUCH_EXPANSION_END,
  TOUCH_EXPANSION_BOTTOM,
  TOUCH_EXPANSION_LEFT,
  TOUCH_EXPANSION_RIGHT,
  TOUCH_EXPANSION_HORIZONTAL,
  TOUCH_EXPANSION_VERTICAL,
  TOUCH_EXPANSION_ALL,
  ELEVATION,
}

/** Common style item for all object styles. See note on [DimenField] about this pattern. */
@PublishedApi
@DataClassGenerate
internal data class ObjectStyleItem(override val field: ObjectField, override val value: Any?) :
    StyleItem<Any?> {
  override fun applyCommonProps(context: ComponentContext, commonProps: CommonProps) {
    when (field) {
      ObjectField.BACKGROUND -> commonProps.background(value as Drawable?)
      ObjectField.CLICKABLE -> commonProps.clickable(value as Boolean)
      ObjectField.CLIP_CHILDREN -> commonProps.clipChildren(value as Boolean)
      ObjectField.CLIP_TO_OUTLINE -> commonProps.clipToOutline(value as Boolean)
      ObjectField.DUPLICATE_CHILDREN_STATES -> commonProps.duplicateChildrenStates(value as Boolean)
      ObjectField.DUPLICATE_PARENT_STATE -> commonProps.duplicateParentState(value as Boolean)
      ObjectField.FOCUSABLE -> commonProps.focusable(value as Boolean)
      ObjectField.FOREGROUND -> commonProps.foreground(value as Drawable?)
      ObjectField.ON_CLICK -> {
        val clickHandler = if (value != null) eventHandler(value as (ClickEvent) -> Unit) else null
        commonProps.clickHandler(clickHandler)
      }
      ObjectField.ON_LONG_CLICK -> {
        val longClickHandler =
            if (value != null) eventHandlerWithReturn(value as ((LongClickEvent) -> Boolean))
            else null
        commonProps.longClickHandler(longClickHandler)
      }
      ObjectField.ON_INTERCEPT_TOUCH -> {
        val interceptTouchHandler =
            if (value != null) eventHandlerWithReturn(value as ((InterceptTouchEvent) -> Boolean))
            else null
        commonProps.interceptTouchHandler(interceptTouchHandler)
      }
      ObjectField.ON_TOUCH -> {
        val touchHandler =
            if (value != null) eventHandler(value as ((TouchEvent) -> Unit)) else null
        commonProps.touchHandler(touchHandler)
      }
      ObjectField.SELECTED -> commonProps.selected(value as Boolean)
      ObjectField.STATE_LIST_ANIMATOR -> commonProps.stateListAnimator(value as StateListAnimator?)
      ObjectField.TEST_KEY -> commonProps.testKey(value as String?)
      ObjectField.TRANSITION_NAME -> commonProps.transitionName(value as String?)
      ObjectField.WRAP_IN_VIEW -> commonProps.wrapInView()
      ObjectField.VIEW_ID -> commonProps.viewId(value as Int)
      ObjectField.VIEW_TAG -> commonProps.viewTag(value)
      ObjectField.VIEW_TAGS -> commonProps.viewTags(value as SparseArray<Any>)
      ObjectField.OUTLINE_PROVIDER -> commonProps.outlineProvider(value as ViewOutlineProvider?)
      ObjectField.ENABLED -> commonProps.enabled(value as Boolean)
    }
  }
}

/** Common style item for all float styles. See note on [FloatField] about this pattern. */
@PublishedApi
@DataClassGenerate
internal data class FloatStyleItem(override val field: FloatField, override val value: Float) :
    StyleItem<Float> {
  override fun applyCommonProps(context: ComponentContext, commonProps: CommonProps) {
    when (field) {
      FloatField.ALPHA -> commonProps.alpha(value)
      FloatField.ROTATION -> commonProps.rotation(value)
      FloatField.ROTATION_X -> commonProps.rotationX(value)
      FloatField.ROTATION_Y -> commonProps.rotationY(value)
      FloatField.SCALE -> commonProps.scale(value)
    }
  }
}

/** Common style item for all float styles. See note on [FloatField] about this pattern. */
@PublishedApi
@DataClassGenerate
internal data class DimenStyleItem(override val field: DimenField, override val value: Dimen) :
    StyleItem<Dimen> {
  override fun applyCommonProps(context: ComponentContext, commonProps: CommonProps) {
    val pixelValue = value.toPixels(context.resourceResolver)
    when (field) {
      DimenField.TOUCH_EXPANSION_START -> commonProps.touchExpansionPx(YogaEdge.START, pixelValue)
      DimenField.TOUCH_EXPANSION_TOP -> commonProps.touchExpansionPx(YogaEdge.TOP, pixelValue)
      DimenField.TOUCH_EXPANSION_END -> commonProps.touchExpansionPx(YogaEdge.END, pixelValue)
      DimenField.TOUCH_EXPANSION_BOTTOM -> commonProps.touchExpansionPx(YogaEdge.BOTTOM, pixelValue)
      DimenField.TOUCH_EXPANSION_LEFT -> commonProps.touchExpansionPx(YogaEdge.LEFT, pixelValue)
      DimenField.TOUCH_EXPANSION_RIGHT -> commonProps.touchExpansionPx(YogaEdge.RIGHT, pixelValue)
      DimenField.TOUCH_EXPANSION_HORIZONTAL ->
          commonProps.touchExpansionPx(YogaEdge.HORIZONTAL, pixelValue)
      DimenField.TOUCH_EXPANSION_VERTICAL ->
          commonProps.touchExpansionPx(YogaEdge.VERTICAL, pixelValue)
      DimenField.TOUCH_EXPANSION_ALL -> commonProps.touchExpansionPx(YogaEdge.ALL, pixelValue)
      DimenField.ELEVATION -> commonProps.shadowElevationPx(pixelValue.toFloat())
    }
  }
}

/**
 * Sets an alpha on the View this Component mounts to. Setting this property will cause the
 * Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setAlpha]
 */
inline fun Style.alpha(alpha: Float): Style = this + FloatStyleItem(FloatField.ALPHA, alpha)

/**
 * Sets a background on the View this Component mounts to. Setting this property will cause the
 * Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setBackground]
 */
inline fun Style.background(background: Drawable?): Style =
    this + ObjectStyleItem(ObjectField.BACKGROUND, background)

/**
 * Sets ColorDrawable of the given color as a background on the View this Component mounts to.
 * Setting this property will cause the Component to be represented as a View at mount time if it
 * wasn't going to already.
 *
 * See [android.view.View.setBackgroundColor]
 */
inline fun Style.backgroundColor(@ColorInt backgroundColor: Int): Style =
    this + ObjectStyleItem(ObjectField.BACKGROUND, ComparableColorDrawable.create(backgroundColor))

inline fun Style.backgroundColor(@ColorInt backgroundColor: Long): Style =
    backgroundColor(backgroundColor.toInt())

/**
 * Sets if the View this Component mounts to should be clickable. Setting this property will cause
 * the Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setClickable]
 */
inline fun Style.clickable(isClickable: Boolean): Style =
    this + ObjectStyleItem(ObjectField.CLICKABLE, isClickable)

/**
 * Sets if the View this Component mounts to should be enabled. Setting this property will cause the
 * Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setClickable]
 */
inline fun Style.enabled(isEnabled: Boolean): Style =
    this + ObjectStyleItem(ObjectField.ENABLED, isEnabled)

/**
 * Setting this to false allows child views of this view to draw outside its bounds, overriding the
 * default behavior. It only applies to direct children. Setting this property will cause the
 * Component to be represented as a View at mount time if it wasn't going to already.
 */
inline fun Style.clipChildren(clipChildren: Boolean): Style =
    this + ObjectStyleItem(ObjectField.CLIP_CHILDREN, clipChildren)

/**
 * Sets whether the View's Outline should be used to clip the contents of the View. Setting this
 * property will cause the Component to be represented as a View at mount time if it wasn't going to
 * already.
 *
 * See [android.view.View.setClipToOutline]
 */
inline fun Style.clipToOutline(clipToOutline: Boolean): Style =
    this + ObjectStyleItem(ObjectField.CLIP_TO_OUTLINE, clipToOutline)

/**
 * Sets whether this ViewGroup's drawable states also include its children's drawable states. This
 * is used, for example, to make a group appear to be focused when its child EditText or button is
 * focused. Setting this property will cause the Component to be represented as a View at mount time
 * if it wasn't going to already.
 *
 * See [android.view.ViewGroup.setAddStatesFromChildren]
 */
inline fun Style.duplicateChildrenStates(duplicateChildrenStates: Boolean): Style =
    this + ObjectStyleItem(ObjectField.DUPLICATE_CHILDREN_STATES, duplicateChildrenStates)

/**
 * Sets whether the View gets its drawable state (focused, pressed, etc.) from its direct parent
 * rather than from itself. Setting this property will cause the Component to be represented as a
 * View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setDuplicateParentStateEnabled]
 */
inline fun Style.duplicateParentState(duplicateParentState: Boolean): Style =
    this + ObjectStyleItem(ObjectField.DUPLICATE_PARENT_STATE, duplicateParentState)

/**
 * Sets an elevation on the View this Component mounts to. Setting this property will cause the
 * Component to be represented as a View at mount time if it wasn't going to already.
 *
 * NOTE: This style will be ignored pre-API 21.
 *
 * See [android.view.View.setElevation]
 */
inline fun Style.elevation(elevation: Dimen): Style =
    this + DimenStyleItem(DimenField.ELEVATION, elevation)

/**
 * Setting this property will cause the Component to be focusable. Setting this property will cause
 * the Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setFocusable]
 */
inline fun Style.focusable(isFocusable: Boolean): Style =
    this + ObjectStyleItem(ObjectField.FOCUSABLE, isFocusable)

/**
 * Sets a foreground on the View this Component mounts to. Setting this property will cause the
 * Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setForeground]
 */
inline fun Style.foreground(foreground: Drawable?): Style =
    this + ObjectStyleItem(ObjectField.FOREGROUND, foreground)

/**
 * Sets ColorDrawable of the given color as a background on the View this Component mounts to.
 * Setting this property will cause the Component to be represented as a View at mount time if it
 * wasn't going to already.
 *
 * See [android.view.View.setForeground]
 */
inline fun Style.foregroundColor(@ColorInt foregroundColor: Int): Style =
    this + ObjectStyleItem(ObjectField.FOREGROUND, ComparableColorDrawable.create(foregroundColor))

/**
 * Sets a listener that will invoke the given lambda when this Component is clicked but only if
 * [enabled] is true. If enabled, setting this property will cause the Component to be represented
 * as a View at mount time if it wasn't going to already.
 */
inline fun Style.onClick(enabled: Boolean = true, noinline action: (ClickEvent) -> Unit): Style =
    this + ObjectStyleItem(ObjectField.ON_CLICK, if (enabled) action else null)

/**
 * Sets a listener that will invoke the given lambda when this Component is long clicked but only if
 * [enabled] is true. If enabled, setting this property will cause the Component to be represented
 * as a View at mount time if it wasn't going to already.
 */
inline fun Style.onLongClick(
    enabled: Boolean = true,
    noinline action: (LongClickEvent) -> Boolean
): Style = this + ObjectStyleItem(ObjectField.ON_LONG_CLICK, if (enabled) action else null)

/**
 * Sets a listener that will invoke the given lambda when this Component is touched but only if
 * [enabled] is true. If enabled, setting this property will cause the Component to be represented
 * as a View at mount time if it wasn't going to already.
 */
inline fun Style.onTouch(enabled: Boolean = true, noinline action: (TouchEvent) -> Boolean): Style =
    this + ObjectStyleItem(ObjectField.ON_TOUCH, if (enabled) action else null)

/**
 * Sets a listener that will intercept all touch screen motion events but only if [enabled] is true.
 * This allows you to watch events as they are dispatched to your children, and take ownership of
 * the current gesture at any point. Implementations should return true if they intercepted the
 * event and wish to receive subsequent events, and false otherwise. If [enabled] is true, setting
 * this property will cause the Component to be represented as a View at mount time if it wasn't
 * going to already.
 *
 * See [android.view.ViewGroup.onInterceptTouchEvent]
 */
inline fun Style.onInterceptTouch(
    enabled: Boolean = true,
    noinline action: (InterceptTouchEvent) -> Boolean
): Style = this + ObjectStyleItem(ObjectField.ON_INTERCEPT_TOUCH, if (enabled) action else null)

/**
 * Sets the degree that this component is rotated around the pivot point. Increasing the value
 * results in clockwise rotation. By default, the pivot point is centered on the component. Setting
 * this property will cause the Component to be represented as a View at mount time if it wasn't
 * going to already.
 *
 * See [android.view.View.setRotation]
 */
inline fun Style.rotation(rotation: Float): Style =
    this + FloatStyleItem(FloatField.ROTATION, rotation)

/**
 * Sets the degree that this component is rotated around the horizontal axis through the pivot
 * point. Setting this property will cause the Component to be represented as a View at mount time
 * if it wasn't going to already.
 *
 * See [android.view.View.setRotationX]
 */
inline fun Style.rotationX(rotationX: Float): Style =
    this + FloatStyleItem(FloatField.ROTATION_X, rotationX)

/**
 * Sets the degree that this component is rotated around the vertical axis through the pivot point.
 * Setting this property will cause the Component to be represented as a View at mount time if it
 * wasn't going to already.
 *
 * See [android.view.View.setRotationY]
 */
inline fun Style.rotationY(rotationY: Float): Style =
    this + FloatStyleItem(FloatField.ROTATION_Y, rotationY)

/**
 * Sets the scale (scaleX and scaleY) on this component. This is mostly relevant for animations and
 * being able to animate size changes. Otherwise for non-animation usecases, you should use the
 * standard layout properties to control the size of your component. Setting this property will
 * cause the Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setScaleX] [android.view.View.setScaleY]
 */
inline fun Style.scale(scale: Float): Style = this + FloatStyleItem(FloatField.SCALE, scale)

/**
 * Changes the selection state of this Component. Setting this property will cause the Component to
 * be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setSelected]
 */
inline fun Style.selected(isSelected: Boolean): Style =
    this + ObjectStyleItem(ObjectField.SELECTED, isSelected)

/**
 * Attaches the provided StateListAnimator to this Component. Setting this property will cause the
 * Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setStateListAnimator]
 *
 * NOTE: This style will be ignored pre-API 21.
 */
inline fun Style.stateListAnimator(stateListAnimator: StateListAnimator?): Style =
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      this + ObjectStyleItem(ObjectField.STATE_LIST_ANIMATOR, stateListAnimator)
    } else {
      this
    }

/**
 * Sets testKey on the View this Component mounts to. Setting this property will cause the Component
 * to be represented as a View at mount time if it wasn't going to already.
 */
inline fun Style.testKey(testKey: String?): Style =
    this + ObjectStyleItem(ObjectField.TEST_KEY, testKey)

/**
 * Sets Activity transition name on the View this Component mounts to. Setting this property will
 * cause the Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setTransitionName]
 */
inline fun Style.transitionName(transitionName: String?): Style =
    this + ObjectStyleItem(ObjectField.TRANSITION_NAME, transitionName)

/**
 * Specifies that this Component should be represented as a View when this hierarchy is mounted.
 *
 * By default a Component does not mount any content. The exceptions to this are if:
 * - The Component renders to a [com.facebook.litho.annotations.MountSpec] with View mount content
 * - The Component has styles that require a View (like [background])
 * - The Component has the wrapInView style
 */
inline fun Style.wrapInView(): Style = this + ObjectStyleItem(ObjectField.WRAP_IN_VIEW, null)

/**
 * Adds a View tag to the [View] this [Component] mounts to. Setting this property will cause the
 * [Component] to be represented as a [View] at mount time if it wasn't going to already.
 *
 * See [android.view.View.setId]
 */
inline fun Style.viewId(@IdRes viewId: Int): Style =
    this + ObjectStyleItem(ObjectField.VIEW_ID, viewId)

/**
 * Adds a View tag to the View this Component mounts to. Setting this property will cause the
 * Component to be represented as a View at mount time if it wasn't going to already.
 *
 * See [android.view.View.setTag]
 */
inline fun Style.viewTag(viewTag: Any): Style =
    this + ObjectStyleItem(ObjectField.VIEW_TAG, viewTag)

/**
 * Adds a set of View tags to the View this Component mounts to. Setting this property will cause
 * the Component to be represented as a View at mount time if it wasn't going to already.
 *
 * For each Int, Any pair in the given SparseArray, `View.setTag(Int, Any)` will be called. These
 * tags can be retrieved with `View.getTag(Int)`
 *
 * See [android.view.View.setTag]
 */
inline fun Style.viewTags(viewTags: SparseArray<out Any>): Style =
    this + ObjectStyleItem(ObjectField.VIEW_TAGS, viewTags)

/**
 * Sets a [ViewOutlineProvider] on the View this Component mounts to. Setting this property will
 * cause the Component to be represented as a View at mount time if it wasn't going to already.
 *
 * NOTE: This style will be ignored pre-API 21.
 *
 * See [android.view.View.setOutlineProvider]
 */
inline fun Style.outlineProvider(outlineProvider: ViewOutlineProvider?): Style =
    this + ObjectStyleItem(ObjectField.OUTLINE_PROVIDER, outlineProvider)

/** Defines touch Expansion area around the component on a per-edge basis. */
inline fun Style.touchExpansion(
    all: Dimen? = null,
    horizontal: Dimen? = null,
    vertical: Dimen? = null,
    start: Dimen? = null,
    top: Dimen? = null,
    end: Dimen? = null,
    bottom: Dimen? = null,
    left: Dimen? = null,
    right: Dimen? = null,
): Style =
    this +
        all?.let { DimenStyleItem(DimenField.TOUCH_EXPANSION_ALL, it) } +
        horizontal?.let { DimenStyleItem(DimenField.TOUCH_EXPANSION_HORIZONTAL, it) } +
        vertical?.let { DimenStyleItem(DimenField.TOUCH_EXPANSION_VERTICAL, it) } +
        start?.let { DimenStyleItem(DimenField.TOUCH_EXPANSION_START, it) } +
        top?.let { DimenStyleItem(DimenField.TOUCH_EXPANSION_TOP, it) } +
        end?.let { DimenStyleItem(DimenField.TOUCH_EXPANSION_END, it) } +
        bottom?.let { DimenStyleItem(DimenField.TOUCH_EXPANSION_BOTTOM, it) } +
        left?.let { DimenStyleItem(DimenField.TOUCH_EXPANSION_LEFT, it) } +
        right?.let { DimenStyleItem(DimenField.TOUCH_EXPANSION_RIGHT, it) }

enum class ShadowStyleField : StyleItemField {
  SHADOW_ITEM,
}

@DataClassGenerate
data class ShadowStyleItemParams(
    val elevation: Dimen,
    val outlineProvider: ViewOutlineProvider,
    @ColorInt val ambientShadowColor: Int,
    @ColorInt val spotShadowColor: Int
)

@PublishedApi
@DataClassGenerate
internal data class ShadowStyleItem(
    val elevation: Dimen,
    val outlineProvider: ViewOutlineProvider,
    @ColorInt val ambientShadowColor: Int,
    @ColorInt val spotShadowColor: Int
) : StyleItem<ShadowStyleItemParams> {

  override fun applyCommonProps(context: ComponentContext, commonProps: CommonProps) {
    commonProps.shadowElevationPx(elevation.toPixels(context.resourceResolver).toFloat())
    commonProps.outlineProvider(outlineProvider)
    commonProps.ambientShadowColor(ambientShadowColor)
    commonProps.spotShadowColor(spotShadowColor)
  }

  override val field: ShadowStyleField = ShadowStyleField.SHADOW_ITEM
  override val value: ShadowStyleItemParams =
      ShadowStyleItemParams(elevation, outlineProvider, ambientShadowColor, spotShadowColor)
}

/**
 * Style for attaching a standard Material Design shadow to a component. Refer to
 * https://material.io/design/environment/light-shadows.html for more information.
 * - **elevation**: Sets the elevation of this component above the surface using
 *   https://developer.android.com/reference/android/view/View#setElevation(float). Larger elevation
 *   values result in larger shadows.
 * - **outlineProvider**: Used to determine the shape of the shadow. If not specified,
 *   https://developer.android.com/reference/android/view/ViewOutlineProvider#BOUNDS will be used to
 *   target the component's bounds.
 * - **ambientShadowColor**: Sets the color of the ambient shadow. Ignored on < API 28 devices. See
 *   https://developer.android.com/reference/android/view/View#setOutlineAmbientShadowColor(int)
 * - **outlineShadowColor**: Sets the color of the spotlight shadow. Ignored on < API 28 devices.
 *   See https://developer.android.com/reference/android/view/View#setOutlineSpotShadowColor(int)
 */
inline fun Style.shadow(
    elevation: Dimen,
    outlineProvider: ViewOutlineProvider = ViewOutlineProvider.BOUNDS,
    @ColorInt ambientShadowColor: Int = Color.BLACK,
    @ColorInt spotShadowColor: Int = Color.BLACK
): Style = this + ShadowStyleItem(elevation, outlineProvider, ambientShadowColor, spotShadowColor)
